# Object Oriented Programming

### What is OOP?
Object-Oriented Programming or OOPs refers to languages that use objects in programming, they use objects as a primary source to implement what is to happen in the code.

### Basic Concept of OOP?
- Inheritance 
- Polymorphism
- Abstraction
- Encapsulation

### TABLE OF CONTENT:
- Class
- Objects
- Encapsulation
- Abstraction
- Polymorphism
- Inheritance
- Dynamic Binding
- Message Passing

# Define Class and Object
Definning class
```
class Geeks {
    // Access specifier
public:
    // Data  Members
    string geekname;
    // Member Functions()
    void printname() 
    { 
    cout << "Geekname is:" << geekname; 
    }
};
```
Declaring Object 
```
int main()
{
    // Declare an object of class geeks
    Geeks obj1;
    // accessing data member
    obj1.geekname = "Abhi";
    // accessing member function
    obj1.printname();
    return 0;
}
```
Declaring member function outside of the class
```
class MyClass {
public:
    void myFunction(); // function declaration inside the class
};

// function definition outside the class
void MyClass::myFunction() {
    // code for the function
}
```

Setter and Getter Code
```
class Person {
  private:
    std::string name;
    int age;
  
  public:
    void setName(std::string newName) {
      name = newName;
    }
  
    std::string getName() const {
      return name;
    }
  
    void setAge(int newAge) {
      age = newAge;
    }
  
    int getAge() const {
      return age;
    }
};
```
# Access Modifier
There are three access modifiers in C++: 
- public
- private
- protected

**Public:** Members declared as public can be accessed from anywhere in the program, including outside the class.
```
class MyClass {
public:
    int myPublicVar; // a public member variable
    void myPublicFunction() { // a public member function
        // code for the function
    }
};
```
<details><summary>EXPLANATION</summary>
<p>
In this example, the myPublicVar member variable and myPublicFunction() member function are declared as public. This means that they can be accessed from anywhere in the program, including outside the class.
</p>
</details>

**Private:** Members declared as private can only be accessed from within the class. 
```
class MyClass {
private:
    int myPrivateVar; // a private member variable
    void myPrivateFunction() { // a private member function
        // code for the function
    }
public:
    void setMyPrivateVar(int value) { // a public member function that can access myPrivateVar
        myPrivateVar = value;
    }
};
```
<details><summary>EXPLANATION</summary>
<p>
In this example, the myPrivateVar member variable and myPrivateFunction() member function are declared as private. This means that they can only be accessed from within the class. However, the setMyPrivateVar() member function is declared as public, so it can be used to set the value of myPrivateVar from outside the class.
</p>
</details>

**Protected:** Members declared as protected can be accessed from within the class and its subclasses
```
class MyClass {
protected:
    int myProtectedVar; // a protected member variable
    void myProtectedFunction() { // a protected member function
        // code for the function
    }
};

class MySubclass : public MyClass {
public:
    void myPublicFunction() { // a public member function that can access myProtectedVar
        myProtectedVar = 42;
    }
};
```
<details><summary>EXPLANATION</summary>
<p>
In this example, the myProtectedVar member variable and myProtectedFunction() member function are declared as protected. This means that they can be accessed from within the class and its subclasses. The MySubclass subclass is derived from MyClass and declares a myPublicFunction() member function that can access myProtectedVar.
</p>
</details>

# Constructor and Destructor

**Constructor Code:**
```
class MyClass {
private:
    int myPrivateVar;
public:
    // constructor declaration
    MyClass(int initialVal) {
        myPrivateVar = initialVal;
    }
};
```
**Constructor Characteristics**
- Constructors have the same name as the class they belong to.
- Constructors do not have a return type, not even void.
- Constructors can be overloaded, meaning that a class can have multiple constructors with different parameters.
- If a class does not define a constructor, a default constructor is automatically generated by the compiler.
- Constructors can have default arguments, allowing objects to be constructed with different combinations of parameters.


**Destructor Code:**
```
class MyClass {
private:
    int *myArray;
public:
    // constructor declaration
    MyClass(int size) {
        myArray = new int[size];
        // other setup code
    }

    // destructor declaration
    ~MyClass() {
        delete[] myArray;
        // other cleanup code
    }
};
```

**Destructor Characteristics**
- Destructors have the same name as the class they belong to, preceded by a tilde (~).
- Destructors do not take any arguments.
- Destructors cannot be overloaded, meaning that a class can only have one destructor.
- If a class does not define a destructor, a default destructor is automatically generated by the compiler. The default destructor simply calls the destructors of all non-static member variables.
- Destructors are always called in the reverse order of the constructors.


# Passing object as function argument  and Returning Object 

## Passing object as function argument

```
class MyClass {
public:
    int value;
};

void printValue(MyClass obj) {
    std::cout << obj.value << std::endl;
}

int main() {
    MyClass myObj;
    myObj.value = 42;
    printValue(myObj);
    return 0;
}
```
<details><summary>EXPLANATION</summary>
<p>
    we have a class called MyClass with a single public integer member variable called value. We also have a function called printValue that takes a MyClass object as an argument and prints its value member variable.

In main(), we create a MyClass object called myObj and set its value member variable to 42. We then call printValue() with myObj as the argument, which causes a copy of myObj to be passed to the function. The printValue() function then prints the value member variable of the copied object.
</p>
</details>

If the object is large or complex, passing it by reference or pointer may be more efficient.
```
void modifyValue(MyClass& obj) {
    obj.value = 100;
}

int main() {
    MyClass myObj;
    myObj.value = 42;
    modifyValue(myObj);
    std::cout << myObj.value << std::endl;
    return 0;
}
```
<details><summary>EXPLANATION</summary>
<p>
    we have a function called modifyValue that takes a MyClass object by reference and sets its value member variable to 100. In main(), we create a MyClass object called myObj and set its value member variable to 42. We then call modifyValue() with myObj as the argument, which modifies the original myObj object. Finally, we print the value member variable of myObj, which now has the value 100.
</p>
</details>


## Returning Object from function

```
class Point {
public:
    int x, y;
    Point(int xCoord, int yCoord) : x(xCoord), y(yCoord) {}
};

Point getOrigin() {
    return Point(0, 0);
}

int main() {
    Point origin = getOrigin();
    std::cout << "The origin is at (" << origin.x << ", " << origin.y << ")" << std::endl;
    return 0;
}
```
<details><summary>EXPLANATION</summary>
<p>
we have a class called Point with two public integer member variables called x and y. We also have a function called getOrigin that creates and returns a Point object with x and y set to 0. In main(), we call getOrigin and store the returned Point object in a variable called origin. We then print the x and y member variables of the origin object
</p>
</details>

If the object is large or complex, returning it by reference or pointer may be more efficient.
```
class Vector {
public:
    int* data;
    int size;
    Vector(int vectorSize) : size(vectorSize) {
        data = new int[size];
    }
    ~Vector() {
        delete[] data;
    }
    int& operator[](int index) {
        return data[index];
    }
};

Vector& createVector(int size) {
    return *(new Vector(size));
}

int main() {
    Vector& myVector = createVector(3);
    myVector[0] = 1;
    myVector[1] = 2;
    myVector[2] = 3;
    std::cout << "The second element of the vector is " << myVector[1] << std::endl;
    delete &myVector;
    return 0;
}
```
<details><summary>EXPLANATION</summary>
<p>
we have a class called Vector that represents a dynamic array of integers. We also have a function called createVector that creates and returns a Vector object by reference. In main(), we call createVector and store the returned Vector object by reference in a variable called myVector. We then set the data member variables of the myVector object and print the second element. Finally, we explicitly delete the myVector object to prevent a memory leak.
</p>
</details>
